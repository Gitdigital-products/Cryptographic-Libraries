// Helper: Convert uint64_t to big-endian bytes
static inline void be64enc(uint8_t *bytes, uint64_t val) {
    bytes[0] = (uint8_t)(val >> 56);
    bytes[1] = (uint8_t)(val >> 48);
    bytes[2] = (uint8_t)(val >> 40);
    bytes[3] = (uint8_t)(val >> 32);
    bytes[4] = (uint8_t)(val >> 24);
    bytes[5] = (uint8_t)(val >> 16);
    bytes[6] = (uint8_t)(val >> 8);
    bytes[7] = (uint8_t)val;
}

// Initialize SHA-256 context
sha256_ctx* sha256_init(void) {
    sha256_ctx *ctx = calloc(1, sizeof(sha256_ctx));
    if (!ctx) {
        return NULL;
    }
    
    // Initialize state with initial hash values
    memcpy(ctx->state, H0, sizeof(H0));
    ctx->total_len = 0;
    ctx->buflen = 0;
    ctx->finalized = false;
    
    return ctx;
}

// Update SHA-256 with more data
int sha256_update(sha256_ctx *ctx, const uint8_t *in, size_t inlen) {
    if (!ctx || ctx->finalized) {
        return -1;
    }
    
    if (inlen == 0) {
        return 0;
    }
    
    ctx->total_len += inlen;
    
    // If we have data in buffer, fill it first
    if (ctx->buflen > 0) {
        size_t to_copy = 64 - ctx->buflen;
        if (to_copy > inlen) {
            to_copy = inlen;
        }
        
        memcpy(ctx->buffer + ctx->buflen, in, to_copy);
        ctx->buflen += to_copy;
        in += to_copy;
        inlen -= to_copy;
        
        // If buffer is full, process it
        if (ctx->buflen == 64) {
            sha256_compress(ctx->state, ctx->buffer);
            ctx->buflen = 0;
        }
    }
    
    // Process complete blocks directly from input
    while (inlen >= 64) {
        sha256_compress(ctx->state, in);
        in += 64;
        inlen -= 64;
    }
    
    // Store any remaining data in buffer
    if (inlen > 0) {
        memcpy(ctx->buffer, in, inlen);
        ctx->buflen = inlen;
    }
    
    return 0;
}

// Finalize SHA-256 and get hash
int sha256_final(sha256_ctx *ctx, uint8_t out[32]) {
    if (!ctx || ctx->finalized) {
        return -1;
    }
    
    uint8_t block[64];
    size_t padlen;
    
    // Total bits as 64-bit integer
    uint64_t total_bits = ctx->total_len * 8;
    
    // Padding starts with 0x80
    if (ctx->buflen < 56) {
        padlen = 56 - ctx->buflen;
    } else {
        padlen = 120 - ctx->buflen; // 64 + 56 - buflen
    }
    
    // Prepare padding block
    if (ctx->buflen > 0) {
        memcpy(block, ctx->buffer, ctx->buflen);
    }
    
    // Add 0x80 byte
    block[ctx->buflen] = 0x80;
    
    // Zero out rest of block
    if (ctx->buflen + 1 + padlen > 64) {
        // Should not happen with our padlen calculation
        return -1;
    }
    
    memset(block + ctx->buflen + 1, 0, padlen);
    
    // Add length in bits at the end
    be64enc(block + 64 - 8, total_bits);
    
    // Process the final block(s)
    if (ctx->buflen < 56) {
        // Fits in one block
        sha256_compress(ctx->state, block);
    } else {
        // Needs two blocks
        // First block contains message + 0x80 + zeros
        sha256_compress(ctx->state, block);
        
        // Second block is zeros + length
        memset(block, 0, 56);
        be64enc(block + 56, total_bits);
        sha256_compress(ctx->state, block);
    }
    
    // Convert state to big-endian bytes
    for (int i = 0; i < 8; i++) {
        be32enc(&out[i * 4], ctx->state[i]);
    }
    
    // Mark as finalized and clear sensitive data
    ctx->finalized = true;
    memset(ctx->state, 0, sizeof(ctx->state));
    memset(ctx->buffer, 0, sizeof(ctx->buffer));
    
    return 0;
}

// Free SHA-256 context
void sha256_free(sha256_ctx *ctx) {
    if (ctx) {
        // Zeroize all sensitive data
        memset(ctx->state, 0, sizeof(ctx->state));
        memset(ctx->buffer, 0, sizeof(ctx->buffer));
        ctx->total_len = 0;
        ctx->buflen = 0;
        ctx->finalized = true;
        free(ctx);
    }
}

// Clone SHA-256 context
int sha256_clone(sha256_ctx *dst, const sha256_ctx *src) {
    if (!dst || !src) {
        return -1;
    }
    
    memcpy(dst, src, sizeof(sha256_ctx));
    return 0;
}