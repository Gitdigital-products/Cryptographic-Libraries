#include <stdint.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include "../../include/crypto_lib/hash.h"

// Test one-shot hashing
int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    if (size == 0) {
        return 0;
    }
    
    uint8_t digest[32];
    
    // Test 1: Basic hash computation (should never crash)
    crypto_hash_sha256(digest, data, size);
    
    // Test 2: Compare incremental vs one-shot for random chunks
    if (size > 1) {
        sha256_ctx *ctx = sha256_init();
        if (!ctx) {
            return 0;
        }
        
        // Split input into random-sized chunks
        size_t processed = 0;
        while (processed < size) {
            // Determine chunk size (at least 1 byte)
            size_t remaining = size - processed;
            size_t chunk_size = 1 + (data[processed] % remaining);
            if (chunk_size > remaining) {
                chunk_size = remaining;
            }
            
            sha256_update(ctx, data + processed, chunk_size);
            processed += chunk_size;
        }
        
        uint8_t incremental_digest[32];
        sha256_final(ctx, incremental_digest);
        sha256_free(ctx);
        
        // They should match (consistency check)
        uint8_t one_shot_digest[32];
        crypto_hash_sha256(one_shot_digest, data, size);
        
        if (memcmp(incremental_digest, one_shot_digest, 32) != 0) {
            // This is a bug! But we can't abort in fuzzing
            // Log it somehow? For now, we just note the mismatch
        }
    }
    
    // Test 3: Test with maximum size (boundary condition)
    if (size > 64) {
        // Test with exactly block size
        crypto_hash_sha256(digest, data, 64);
        
        // Test with just under block size
        crypto_hash_sha256(digest, data, 63);
        
        // Test with just over block size
        crypto_hash_sha256(digest, data, 65);
    }
    
    // Test 4: Clone context test
    if (size > 10) {
        sha256_ctx *ctx1 = sha256_init();
        sha256_ctx *ctx2 = sha256_init();
        
        if (ctx1 && ctx2) {
            // Update both contexts with same data
            size_t half = size / 2;
            sha256_update(ctx1, data, half);
            sha256_update(ctx2, data, half);
            
            // Clone ctx1
            sha256_ctx *ctx1_clone = sha256_init();
            if (ctx1_clone) {
                sha256_clone(ctx1_clone, ctx1);
                
                // Continue updating both
                sha256_update(ctx1, data + half, size - half);
                sha256_update(ctx1_clone, data + half, size - half);
                
                // Finalize and compare
                uint8_t digest1[32], digest1_clone[32];
                sha256_final(ctx1, digest1);
                sha256_final(ctx1_clone, digest1_clone);
                
                if (memcmp(digest1, digest1_clone, 32) != 0) {
                    // Clone inconsistency!
                }
                
                sha256_free(ctx1_clone);
            }
            
            // Finalize ctx2 differently
            uint8_t digest2[32];
            sha256_update(ctx2, data + half, size - half);
            sha256_final(ctx2, digest2);
            
            sha256_free(ctx1);
            sha256_free(ctx2);
        }
    }
    
    return 0;
}